			+--------------------+
			|    EDA092/DIT400   |
			| LAB ASSIGNMENT 2:  |
			| 	THREADS      |
			|   DESIGN DOCUMENT  |
			+--------------------+

---- GROUP XX ----

>> Fill in the group number, names and email addresses of your group members.

Christoffer Olsson <chol@chalmers.se>
Kajsa Lenfors <lenfors@chalmers.se>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

Synchronizqaion/resource allocation exercise session and particulary looked at the Bridge problem.

			     ALARM CLOCK
			     ===========

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct thread
  {
	// An integer that will receive time from OS start + sleep time,
	// used to keep track when thread should wake up
	int wakeup_time;
	};

	//Lock structure
	struct lock locked_thread;

	// Condition struct for non-priority tasks
	struct condition conditionToGo[2];

	// Condition struct for-priority tasks
	struct condition conditionToGoPrio[2];

	// The number non-priority of tasks waiting to go in each direction
	int waiters[2];

	// The number of priority tasks waiting to go in each direction
	int waitersPrio[2];

	// Integer to show how many tasks that are currently running
	int runningTasks;

	// Integer to show in which direction tasks are running, SEND or RECEIVE
	int currentdirection;


---- ALGORITHMS ----

>> A2: Briefly describe what happens in a call to timer_sleep(),
>> including the effects of the timer interrupt handler.

VÅRAT SVAR : The input ticks determents how long the process should sleep. Timer_sleep calls timer_ticks() to get a start value and calculates a
wakeup time. Interrupt is then disabled and the thread is blocked until timer_interrupt() calls check_timer() to unblock the thread if the time has passed.


DERAS SVAR:  timer_sleep() is called with a ticks as argument. The number of ticks determine for how long time
the thread should be blocked. The ticks and current time is added and forms variable wut before
the thread is blocked.
timer_interrupt() calls timer_check_wut() which purpose is to unblock the thread
using information regarding blocked threads, the threads wut and the current time.




>> A3: What steps are taken to minimize the amount of time spent in
>> the timer interrupt handler?

VÅRAT SVAR: timer_interrupt() calls another function that uses thread_foreach() to loop through all threads to find threads ready to wakeup.

DERAS SVAR: timer_interrupt() calls timer_check_wut() which in turn uses thread_foreach()
to fo through all existing threads to find the ones we are interested of.




---- SYNCHRONIZATION ----

>> A4: How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?


They each compute their own wake up time based on the current tick and store it seperately.




>> A5: How are race conditions avoided when a timer interrupt occurs
>> during a call to timer_sleep()?

VÅRAT: Interrupts are disabled before a thread is blocked. Interrupts are then enagbled again afterwards.


DERAS: Before the thread is blocked, the interrupts are disabled and are re enabled after the thread block call.




---- RATIONALE ----

>> A6: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

We thought it was most straight forward to set a wake up time,
and use this together with information
on the status of threads (using thread_foreach) and the current time to wake the
threads up at the correct time. We never really considered other designs.




			    BATCH SCHEDULING
			    ================
---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, semaphore, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct lock lockB;									/* Creating struct of the lock */
struct condition waitingPrio[2];		/* Conditions to use with our lock regarding priority waiting list for both directions */
struct condition waiting[2];				/* Conditions to use with our lock regarding non priority waiting list for both directions */

int currentDirection; 							/* Defines the direction for the tasks on the bus */
int waitingForBusPrio[2];						/* Number of priority tasks waiting for the bus, separated by direction */
int waitingForBus[2];								/* Number of non priority tasks waiting for the bus, separated by direction */
int busTasks;												/* Number of tasks on the bus */




---- SYNCHRONIZATION ----

>> C1: How does your solution guarantee that no more that 3 tasks
>> are using the bus in the same direction?

Tasks get a slot on the bus until the bus is full. Afterwards a task can´t
get access to the bus until another leaves the bus.




>> C2: What prevents tasks from opposite directions from using the
>> bus simultaneously?

  Once the bus have been accessed by a task in a given direction it can only
  change if there are no more tasks in that direction or if the other direction
  have priority tasks and the current does not.




>> C3: How does your solution grant priority to high priority tasks over
>> the waiting tasks in the same direction?

  When a task has finished no matter what priority, it always checks if there are
  any priority tasks left in and then wakes the ones in the current direction.
	After that tasks in the other direction are woken up.




>> C4: How do you guarantee that despite having priority, high priority
>> tasks do not start using the bus while there are still still using
>> it in the oposite direction?

  When a task has finished no matter what priority it always checks if there are
  any priority tasks left in and then wakes the ones in the current direction and
  after that the one that are in the other direction.




---- RATIONALE ----

>> C6: Why did you choose this design? Did you consider other design
>> alternatives? In what ways is it superior to another design you considered?

  First we used a design that was incorrect due to understanding the problem incorrectly and
	we did the bus scheduling in a sequentuial manner rather of a parallell. After correcting
	for this we used semephores to control the scheduling of the bus. It however turned out
	to be easier using locks and condition variables rather than semaphores, as needed
	functions already had	had been implemented for this, so we once again switched design
	to make our coding easier.




			   SURVEY QUESTIONS (optional)
			   ===========================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

  As always, once you understood the problem and knew where to look for help it was not hard.
  The problem is always to get to know the code and fin out where to find the functions
	to use (for example cond_signal, lock_acquire etc). The main problem of this lab
	was to understand what to do and how to plan for the code.

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

  Nothing that stands out, almost everything gave insight.

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

  Be clear on what we are supposed to do. We misunderstood task 2 and designed for
	a sequential scheduler rather than a parallel one. A bit more clear information of
	this part could have save us 6 hours.
  Be clear on where to find information (i.e all the functions for semaphores, locks etc).
  A lot of unnecessary time were spent on trying to fix error messages from including "semaphore.h"
  and trying to work with that, before we found out that we were to use the semaphores as
	implemented in the pintos code.
	We found or lack of C programming knowledge limiting and we did not know if we
  caused the problem or if we were working with the wrong functions. Another lab session
	with lab TAs, rather than having to work alone would have helped us in this. The
	limited time in the lab was definately a stress factor for us.

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters?

>> Any other comments?
One more lab session where you could work on your code and ask tha TAs for help.
